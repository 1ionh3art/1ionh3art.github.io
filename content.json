{"meta":{"title":"Lionheart","subtitle":"Have a nice day!","description":"知其然更知其所以然","author":"1ionh3art","url":"https://1ionh3art.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-03T14:03:19.000Z","updated":"2019-11-10T11:24:32.458Z","comments":false,"path":"categories/index.html","permalink":"https://1ionh3art.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-03T14:02:34.000Z","updated":"2019-11-10T11:23:32.149Z","comments":false,"path":"about/index.html","permalink":"https://1ionh3art.github.io/about/index.html","excerpt":"","text":""},{"title":"聆听","date":"2019-11-09T17:43:12.722Z","updated":"2019-11-09T17:43:12.722Z","comments":false,"path":"music/index.html","permalink":"https://1ionh3art.github.io/music/index.html","excerpt":"","text":""},{"title":"日程表","date":"2019-04-03T14:03:37.000Z","updated":"2019-04-04T09:06:39.053Z","comments":false,"path":"schedule/index.html","permalink":"https://1ionh3art.github.io/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-03T14:02:49.000Z","updated":"2019-11-10T11:09:40.198Z","comments":false,"path":"tags/index.html","permalink":"https://1ionh3art.github.io/tags/index.html","excerpt":"","text":""},{"title":"远方","date":"2019-11-10T11:24:59.110Z","updated":"2019-11-10T11:24:59.110Z","comments":false,"path":"photo/index.html","permalink":"https://1ionh3art.github.io/photo/index.html","excerpt":"","text":"2019 →09 南京 ●中山陵 ●总统府 ●夫子庙 ●南京大排档 →04 日本●成都—东京 ●秋叶原 ●上野公园 ●浅草寺 ●天空树 ●皇居 ●目黑川河 ●台场 ●新宿 ●镰仓 ●东京迪士尼"},{"title":"","date":"2019-04-03T05:48:20.860Z","updated":"2019-04-03T05:48:20.860Z","comments":true,"path":"lib/canvas-nest/canvas-nest-nomobile.min.js","permalink":"https://1ionh3art.github.io/lib/canvas-nest/canvas-nest-nomobile.min.js","excerpt":"","text":"!function(){ var userAgentInfo = navigator.userAgent; var Agents = [\"iPad\", \"iPhone\", \"Android\", \"SymbianOS\", \"Windows Phone\", \"iPod\", \"webOS\", \"BlackBerry\", \"IEMobile\"]; for (var v = 0; v < Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) > 0) { return; } } function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j(\"script\"),w=i.length,v=i[w-1];return{l:w,z:o(v,\"zIndex\",-1),o:o(v,\"opacity\",0.5),c:o(v,\"color\",\"0,0,0\"),n:o(v,\"count\",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.xn||i.y"},{"title":"","date":"2019-04-03T05:48:20.859Z","updated":"2019-04-03T05:48:20.859Z","comments":true,"path":"lib/canvas-nest/README.html","permalink":"https://1ionh3art.github.io/lib/canvas-nest/README.html","excerpt":"","text":"canvas-nest.js for NexT Installation Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines And, if you wants to use the CDN, then need to set: 1234vendors: ... canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest-nomobile.min.js Update 12$ cd themes/next/source/lib/canvas-nest$ git pull"},{"title":"","date":"2019-04-03T05:48:20.860Z","updated":"2019-04-03T05:48:20.860Z","comments":true,"path":"lib/canvas-nest/canvas-nest.min.js","permalink":"https://1ionh3art.github.io/lib/canvas-nest/canvas-nest.min.js","excerpt":"","text":"!function(){function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j(\"script\"),w=i.length,v=i[w-1];return{l:w,z:o(v,\"zIndex\",-1),o:o(v,\"opacity\",0.5),c:o(v,\"color\",\"0,0,0\"),n:o(v,\"count\",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.xn||i.y"}],"posts":[{"title":"记一次生产环境系统卡死引申的JVM调优","slug":"dld_jvm_optimize","date":"2019-07-07T11:04:14.000Z","updated":"2019-11-10T06:51:58.496Z","comments":true,"path":"2019/07/07/dld_jvm_optimize/","link":"","permalink":"https://1ionh3art.github.io/2019/07/07/dld_jvm_optimize/","excerpt":"前几天公司实施人员反映，某个生产环境的系统运行二三十分钟后会卡死，无法进行任何操作，重启项目后恢复正常。该tomcat未配置任何JVM参数，初步推测可能是内存泄露。在此记录一下分析过程。","text":"前几天公司实施人员反映，某个生产环境的系统运行二三十分钟后会卡死，无法进行任何操作，重启项目后恢复正常。该tomcat未配置任何JVM参数，初步推测可能是内存泄露。在此记录一下分析过程。 GC日志分析添加JVM启动参数1234-XX:+PrintGCDetails #打印GC详细信息#-XX:+PrintGCTimeStamps #打印GC时间戳#-XX:+PrintHeapAtGC #打印GC前后堆信息#-Xloggc:../logs/gc.log #日志输出目录# 启动运行16分钟后，取出日志文件得到GC分析结果： GC详情总停顿时间 4.42 秒总停顿次数（GC次数） 83 次最短停顿时间 0.00478 秒/最长停顿时间 1.29812 秒累计FULL GC时间 2.49 秒，占总GC时间 56.3%FULL GC次数 5 次最短FULL GC时间 0.0866 秒/最长FULL GC时间 1.29812 秒累计MINOR GC时间 1.93 秒，占总GC时间 43.7%累计MINOR GC次数 78 次 在短短 16 分钟时间里，系统一共进行了 83 次GC，其中有5次FULL GC，78次MINOR GC，FULL GC占总GC时间的 56.3% ，这个FULL GC是不正常的，太频繁了，用户访问时发生GC，会延长响应时间，这对于用户体验是非常不好的。 为什么会出现这么多次的FULL GC呢？ 找到GC日志中FULL GC的信息： 18.039: [Full GC (Metadata GC Threshold) 18.039: [Tenured: 40544K-&gt;43471K(1398144K), 0.0865097 secs] 220002K-&gt;43471K(2027264K), [Metaspace: 20727K-&gt;20727K(1069056K)], 0.0866007 secs] [Times: user=0.09 sys=0.00, real=0.09 secs] 21.910: [Full GC (Metadata GC Threshold) 21.910: [Tenured: 43471K-&gt;66990K(1398144K), 0.2029932 secs] 317046K-&gt;66990K(2027264K), [Metaspace: 34797K-&gt;34797K(1079296K)], 0.2031175 secs] [Times: user=0.27 sys=0.01, real=0.20 secs] 30.469: [Full GC (Metadata GC Threshold) 30.469: [Tenured: 66990K-&gt;83953K(1398144K), 0.2302324 secs] 252285K-&gt;83953K(2027264K), [Metaspace: 58292K-&gt;58292K(1099776K)], 0.2303375 secs] [Times: user=0.25 sys=0.00, real=0.23 secs] 55.141: [Full GC (Metadata GC Threshold) 55.141: [Tenured: 150599K-&gt;152385K(1398144K), 0.6668494 secs] 587108K-&gt;152385K(2027264K), [Metaspace: 96952K-&gt;96952K(1136640K)], 0.6669745 secs] [Times: user=0.66 sys=0.00, real=0.67 secs] 977.356: [Full GC (Metadata GC Threshold) 977.356: [Tenured: 406487K-&gt;443272K(1398144K), 1.2979688 secs] 903258K-&gt;443272K(2027264K), [Metaspace: 160504K-&gt;160504K(1196032K)], 1.2981206 secs] [Times: user=1.29 sys=0.01, real=1.30 secs] 可以看到，前4次FULL GC发生的时间为系统启动后18秒、21秒、30秒、55秒，这段时间应该是tomcat正在启动项目；第5次FULL GC发生在系统启动后977秒。同时，可以看到FULL GC原因是Metadata GC Threshold，意思是元数据区达到阈值，从而发生FULL GC。 原因 目前，有的项目并没有配置jvm启动参数，有的项目配置了，但是其中依然使用的PermGen，永久代在jdk8中已经完全移除，取而代之的是Metaspace（元数据区），元数据区使用的是本地内存，与堆大小无关，且在不设置上限的情况下，会一直扩容，直到把内存吞噬殆尽，导致系统无法响应，服务器上其他程序也无法使用。 JVM默认的元数据区的阈值是21m，因此，在系统启动过程中，加载的类信息很容易就超过这个阈值，从而触发FULL GC；如果用户请求中的业务逻辑加载了新的类数据，也会触发一次FULL GC，因此使得请求响应变慢。 因此添加JVM参数：12-XX:MetaspaceSize=256M #元数据区阈值#-XX:MaxMetaspaceSize=256M #元数据区最大值# 同时分析日志 eden space 559232K, 79% used [0x0000000080000000, 0x000000009b035050, 0x00000000a2220000)from space 69888K, 77% used [0x00000000a2220000, 0x00000000a570ba90, 0x00000000a6660000)to space 69888K, 0% used [0x00000000a6660000, 0x00000000a6660000, 0x00000000aaaa0000)tenured generation total 1398144K, used 406487K [0x00000000aaaa0000, 0x0000000100000000, 0x0000000100000000) 可以看到老年代当前为406m，之后还会略微增长，因此我们可以向上推测出活跃数据大概在500m左右，然后根据 设置堆大小2G，新生代768m，老年代1332m，新生代eden与survivor的比例使用默认8:1:1，由于之前没有指定垃圾收集器，则jvm默认使用UseParallelGC，该收集器新生代使用Parallel Scavenge多线程并行收集，但是老年代使用的是Serial Old，这是一个单线程收集器，垃圾回收效率没有并行收集高，因此改为新生代使用UseParNewGC，老年代使用UseConcMarkSweepGC，这两个垃圾收集器都使用并行收集，CMS关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。 最终JVM参数配置1234567891011121314-server-Xms2G -Xmx2G-XX:MetaspaceSize=256M-XX:MaxMetaspaceSize=256M-XX:+UseParNewGC-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15-XX:NewSize=768m-XX:MaxNewSize=768m-XX:+HeapDumpOnOutOfMemoryError-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC -Xloggc:../logs/gc.log 上述参数配置后，系统在运行了55分钟后，取出GC日志再次分析，得到分析结果： 修改后GC详情一共进行了 81 次GC，累计停顿时间 2.67 秒，最短停顿时间 0.01256 秒/最长停顿时间 0.12997 秒，平均停顿时间 0.03298 秒，其中0次FULL GC，全是MINOR GC 查看日志： 3264.136: [GC (Allocation Failure) 3264.136: [ParNew: 683860K-&gt;52269K(707840K), 0.0343536 secs] 1147153K-&gt;530284K(2018560K), 0.0345308 secs] [Times: user=0.31 sys=0.00, real=0.04 secs] 3331.824: [GC (Allocation Failure) 3331.824: [ParNew: 681517K-&gt;40268K(707840K), 0.0257484 secs] 1159532K-&gt;518283K(2018560K), 0.0259169 secs] [Times: user=0.29 sys=0.00, real=0.03 secs] 3339.513: [GC (Allocation Failure) 3339.513: [ParNew: 669516K-&gt;41968K(707840K), 0.0248916 secs] 1147531K-&gt;519983K(2018560K), 0.0250382 secs] [Times: user=0.29 sys=0.00, real=0.02 secs] 可知，所有的GC都发生在新生代eden区满了的情况下，绝大部分数据在新生代就被回收，这才是正常的GC情况。 至此，系统恢复正常。由于会不定时发布新功能，因此后期会定期拉取GC日志分析，根据实际情况再进行优化。 修改前后GC图修改前 修改后","categories":[{"name":"后端","slug":"后端","permalink":"https://1ionh3art.github.io/categories/后端/"},{"name":"JAVA","slug":"后端/JAVA","permalink":"https://1ionh3art.github.io/categories/后端/JAVA/"},{"name":"JVM","slug":"后端/JAVA/JVM","permalink":"https://1ionh3art.github.io/categories/后端/JAVA/JVM/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://1ionh3art.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://1ionh3art.github.io/tags/JVM/"}]}]}