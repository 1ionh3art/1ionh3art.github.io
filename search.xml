<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次生产环境系统卡死引申的JVM调优]]></title>
    <url>%2F2019%2F07%2F07%2Fdld_jvm_optimize%2F</url>
    <content type="text"><![CDATA[前几天公司实施人员反映，某个生产环境的系统运行二三十分钟后会卡死，无法进行任何操作，重启项目后恢复正常。该tomcat未配置任何JVM参数，初步推测可能是内存泄露。在此记录一下分析过程。 GC日志分析添加JVM启动参数1234-XX:+PrintGCDetails #打印GC详细信息#-XX:+PrintGCTimeStamps #打印GC时间戳#-XX:+PrintHeapAtGC #打印GC前后堆信息#-Xloggc:../logs/gc.log #日志输出目录# 启动运行16分钟后，取出日志文件得到GC分析结果： GC详情总停顿时间 4.42 秒总停顿次数（GC次数） 83 次最短停顿时间 0.00478 秒/最长停顿时间 1.29812 秒累计FULL GC时间 2.49 秒，占总GC时间 56.3%FULL GC次数 5 次最短FULL GC时间 0.0866 秒/最长FULL GC时间 1.29812 秒累计MINOR GC时间 1.93 秒，占总GC时间 43.7%累计MINOR GC次数 78 次 在短短 16 分钟时间里，系统一共进行了 83 次GC，其中有5次FULL GC，78次MINOR GC，FULL GC占总GC时间的 56.3% ，这个FULL GC是不正常的，太频繁了，用户访问时发生GC，会延长响应时间，这对于用户体验是非常不好的。 为什么会出现这么多次的FULL GC呢？ 找到GC日志中FULL GC的信息： 18.039: [Full GC (Metadata GC Threshold) 18.039: [Tenured: 40544K-&gt;43471K(1398144K), 0.0865097 secs] 220002K-&gt;43471K(2027264K), [Metaspace: 20727K-&gt;20727K(1069056K)], 0.0866007 secs] [Times: user=0.09 sys=0.00, real=0.09 secs] 21.910: [Full GC (Metadata GC Threshold) 21.910: [Tenured: 43471K-&gt;66990K(1398144K), 0.2029932 secs] 317046K-&gt;66990K(2027264K), [Metaspace: 34797K-&gt;34797K(1079296K)], 0.2031175 secs] [Times: user=0.27 sys=0.01, real=0.20 secs] 30.469: [Full GC (Metadata GC Threshold) 30.469: [Tenured: 66990K-&gt;83953K(1398144K), 0.2302324 secs] 252285K-&gt;83953K(2027264K), [Metaspace: 58292K-&gt;58292K(1099776K)], 0.2303375 secs] [Times: user=0.25 sys=0.00, real=0.23 secs] 55.141: [Full GC (Metadata GC Threshold) 55.141: [Tenured: 150599K-&gt;152385K(1398144K), 0.6668494 secs] 587108K-&gt;152385K(2027264K), [Metaspace: 96952K-&gt;96952K(1136640K)], 0.6669745 secs] [Times: user=0.66 sys=0.00, real=0.67 secs] 977.356: [Full GC (Metadata GC Threshold) 977.356: [Tenured: 406487K-&gt;443272K(1398144K), 1.2979688 secs] 903258K-&gt;443272K(2027264K), [Metaspace: 160504K-&gt;160504K(1196032K)], 1.2981206 secs] [Times: user=1.29 sys=0.01, real=1.30 secs] 可以看到，前4次FULL GC发生的时间为系统启动后18秒、21秒、30秒、55秒，这段时间应该是tomcat正在启动项目；第5次FULL GC发生在系统启动后977秒。同时，可以看到FULL GC原因是Metadata GC Threshold，意思是元数据区达到阈值，从而发生FULL GC。 原因 目前，有的项目并没有配置jvm启动参数，有的项目配置了，但是其中依然使用的PermGen，永久代在jdk8中已经完全移除，取而代之的是Metaspace（元数据区），元数据区使用的是本地内存，与堆大小无关，且在不设置上限的情况下，会一直扩容，直到把内存吞噬殆尽，导致系统无法响应，服务器上其他程序也无法使用。 JVM默认的元数据区的阈值是21m，因此，在系统启动过程中，加载的类信息很容易就超过这个阈值，从而触发FULL GC；如果用户请求中的业务逻辑加载了新的类数据，也会触发一次FULL GC，因此使得请求响应变慢。 因此添加JVM参数：12-XX:MetaspaceSize=256M #元数据区阈值#-XX:MaxMetaspaceSize=256M #元数据区最大值# 同时分析日志 eden space 559232K, 79% used [0x0000000080000000, 0x000000009b035050, 0x00000000a2220000)from space 69888K, 77% used [0x00000000a2220000, 0x00000000a570ba90, 0x00000000a6660000)to space 69888K, 0% used [0x00000000a6660000, 0x00000000a6660000, 0x00000000aaaa0000)tenured generation total 1398144K, used 406487K [0x00000000aaaa0000, 0x0000000100000000, 0x0000000100000000) 可以看到老年代当前为406m，之后还会略微增长，因此我们可以向上推测出活跃数据大概在500m左右，然后根据 设置堆大小2G，新生代768m，老年代1332m，新生代eden与survivor的比例使用默认8:1:1，由于之前没有指定垃圾收集器，则jvm默认使用UseParallelGC，该收集器新生代使用Parallel Scavenge多线程并行收集，但是老年代使用的是Serial Old，这是一个单线程收集器，垃圾回收效率没有并行收集高，因此改为新生代使用UseParNewGC，老年代使用UseConcMarkSweepGC，这两个垃圾收集器都使用并行收集，CMS关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。 最终JVM参数配置1234567891011121314-server-Xms2G -Xmx2G-XX:MetaspaceSize=256M-XX:MaxMetaspaceSize=256M-XX:+UseParNewGC-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15-XX:NewSize=768m-XX:MaxNewSize=768m-XX:+HeapDumpOnOutOfMemoryError-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC -Xloggc:../logs/gc.log 上述参数配置后，系统在运行了55分钟后，取出GC日志再次分析，得到分析结果： 修改后GC详情一共进行了 81 次GC，累计停顿时间 2.67 秒，最短停顿时间 0.01256 秒/最长停顿时间 0.12997 秒，平均停顿时间 0.03298 秒，其中0次FULL GC，全是MINOR GC 查看日志： 3264.136: [GC (Allocation Failure) 3264.136: [ParNew: 683860K-&gt;52269K(707840K), 0.0343536 secs] 1147153K-&gt;530284K(2018560K), 0.0345308 secs] [Times: user=0.31 sys=0.00, real=0.04 secs] 3331.824: [GC (Allocation Failure) 3331.824: [ParNew: 681517K-&gt;40268K(707840K), 0.0257484 secs] 1159532K-&gt;518283K(2018560K), 0.0259169 secs] [Times: user=0.29 sys=0.00, real=0.03 secs] 3339.513: [GC (Allocation Failure) 3339.513: [ParNew: 669516K-&gt;41968K(707840K), 0.0248916 secs] 1147531K-&gt;519983K(2018560K), 0.0250382 secs] [Times: user=0.29 sys=0.00, real=0.02 secs] 可知，所有的GC都发生在新生代eden区满了的情况下，绝大部分数据在新生代就被回收，这才是正常的GC情况。 至此，系统恢复正常。由于会不定时发布新功能，因此后期会定期拉取GC日志分析，根据实际情况再进行优化。 修改前后GC图修改前 修改后]]></content>
      <categories>
        <category>JAVA</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
