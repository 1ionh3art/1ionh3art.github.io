<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heart4lion&#39;s Clannad</title>
  
  <subtitle>Have a nice day!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heart4lion.github.io/"/>
  <updated>2019-07-08T07:11:52.597Z</updated>
  <id>https://heart4lion.github.io/</id>
  
  <author>
    <name>heart4lion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次生产环境系统卡死引申的JVM调优</title>
    <link href="https://heart4lion.github.io/2019/07/07/dld_jvm_optimize/"/>
    <id>https://heart4lion.github.io/2019/07/07/dld_jvm_optimize/</id>
    <published>2019-07-07T11:04:14.000Z</published>
    <updated>2019-07-08T07:11:52.597Z</updated>
    
    <content type="html"><![CDATA[<p>前几天公司实施人员反映，某个生产环境的系统运行二三十分钟后会卡死，无法进行任何操作，重启项目后恢复正常。该tomcat未配置任何JVM参数，初步推测可能是内存泄露。在此记录一下分析过程。</p><a id="more"></a><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><h3 id="添加JVM启动参数"><a href="#添加JVM启动参数" class="headerlink" title="添加JVM启动参数"></a>添加JVM启动参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails   <span class="comment">#打印GC详细信息#</span></span><br><span class="line">-XX:+PrintGCTimeStamps    <span class="comment">#打印GC时间戳#</span></span><br><span class="line">-XX:+PrintHeapAtGC      <span class="comment">#打印GC前后堆信息#</span></span><br><span class="line">-Xloggc:../logs/gc.log     <span class="comment">#日志输出目录#</span></span><br></pre></td></tr></table></figure><p>启动运行16分钟后，取出日志文件得到GC分析结果：<br><img src="/images/dld_jvm_optimize/dld_jvm_optimize1.png" alt></p><h3 id="GC详情"><a href="#GC详情" class="headerlink" title="GC详情"></a>GC详情</h3><p><strong>总停顿时间 4.42 秒<br>总停顿次数（GC次数） 83 次<br>最短停顿时间 0.00478 秒/最长停顿时间 1.29812 秒<br>累计FULL GC时间 2.49 秒，占总GC时间 56.3%<br>FULL GC次数 5 次<br>最短FULL GC时间 0.0866 秒/最长FULL GC时间 1.29812 秒<br>累计MINOR GC时间 1.93 秒，占总GC时间 43.7%<br>累计MINOR GC次数 78 次</strong></p><p>在短短 16 分钟时间里，系统一共进行了 83 次GC，其中有5次FULL GC，78次MINOR GC，FULL GC占总GC时间的 56.3% ，这个FULL GC是不正常的，太频繁了，用户访问时发生GC，会延长响应时间，这对于用户体验是非常不好的。</p><p><strong>为什么会出现这么多次的FULL GC呢？</strong></p><p>找到GC日志中FULL GC的信息：</p><ul><li><p><strong>18.039: [Full GC (Metadata GC Threshold) 18.039: [Tenured: 40544K-&gt;43471K(1398144K), 0.0865097 secs] 220002K-&gt;43471K(2027264K), [Metaspace: 20727K-&gt;20727K(1069056K)], 0.0866007 secs] [Times: user=0.09 sys=0.00, real=0.09 secs]</strong></p></li><li><p><strong>21.910: [Full GC (Metadata GC Threshold) 21.910: [Tenured: 43471K-&gt;66990K(1398144K), 0.2029932 secs] 317046K-&gt;66990K(2027264K), [Metaspace: 34797K-&gt;34797K(1079296K)], 0.2031175 secs] [Times: user=0.27 sys=0.01, real=0.20 secs]</strong></p></li><li><p><strong>30.469: [Full GC (Metadata GC Threshold) 30.469: [Tenured: 66990K-&gt;83953K(1398144K), 0.2302324 secs] 252285K-&gt;83953K(2027264K), [Metaspace: 58292K-&gt;58292K(1099776K)], 0.2303375 secs] [Times: user=0.25 sys=0.00, real=0.23 secs]</strong></p></li><li><p><strong>55.141: [Full GC (Metadata GC Threshold) 55.141: [Tenured: 150599K-&gt;152385K(1398144K), 0.6668494 secs] 587108K-&gt;152385K(2027264K), [Metaspace: 96952K-&gt;96952K(1136640K)], 0.6669745 secs] [Times: user=0.66 sys=0.00, real=0.67 secs]</strong></p></li><li><p><strong>977.356: [Full GC (Metadata GC Threshold) 977.356: [Tenured: 406487K-&gt;443272K(1398144K), 1.2979688 secs] 903258K-&gt;443272K(2027264K), [Metaspace: 160504K-&gt;160504K(1196032K)], 1.2981206 secs] [Times: user=1.29 sys=0.01, real=1.30 secs]</strong></p></li></ul><p>可以看到，前4次FULL GC发生的时间为系统启动后18秒、21秒、30秒、55秒，这段时间应该是tomcat正在启动项目；第5次FULL GC发生在系统启动后977秒。同时，可以看到FULL GC原因是Metadata GC Threshold，意思是元数据区达到阈值，从而发生FULL GC。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>目前，有的项目并没有配置jvm启动参数，有的项目配置了，但是其中依然使用的PermGen，永久代在jdk8中已经完全移除，取而代之的是Metaspace（元数据区），元数据区使用的是本地内存，与堆大小无关，且在不设置上限的情况下，会一直扩容，直到把内存吞噬殆尽，导致系统无法响应，服务器上其他程序也无法使用。</li><li>JVM默认的元数据区的阈值是21m，因此，在系统启动过程中，加载的类信息很容易就超过这个阈值，从而触发FULL GC；如果用户请求中的业务逻辑加载了新的类数据，也会触发一次FULL GC，因此使得请求响应变慢。</li></ol><p>因此添加JVM参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=256M    <span class="comment">#元数据区阈值#</span></span><br><span class="line">-XX:MaxMetaspaceSize=256M     <span class="comment">#元数据区最大值#</span></span><br></pre></td></tr></table></figure></p><p>同时分析日志</p><p><strong>eden space 559232K,  79% used [0x0000000080000000, 0x000000009b035050, 0x00000000a2220000)</strong><br><strong>from space 69888K,  77% used [0x00000000a2220000, 0x00000000a570ba90, 0x00000000a6660000)</strong><br><strong>to   space 69888K,   0% used [0x00000000a6660000, 0x00000000a6660000, 0x00000000aaaa0000)</strong><br><strong>tenured generation   total 1398144K, used 406487K [0x00000000aaaa0000, 0x0000000100000000, 0x0000000100000000)</strong></p><p>可以看到老年代当前为406m，之后还会略微增长，因此我们可以向上推测出活跃数据大概在500m左右，然后根据<br><img src="/images/dld_jvm_optimize/dld_jvm_optimize2.png" alt></p><p>设置堆大小2G，新生代768m，老年代1332m，新生代eden与survivor的比例使用默认8:1:1，由于之前没有指定垃圾收集器，则jvm默认使用UseParallelGC，该收集器新生代使用Parallel Scavenge多线程并行收集，但是老年代使用的是Serial Old，这是一个单线程收集器，垃圾回收效率没有并行收集高，因此改为新生代使用UseParNewGC，老年代使用UseConcMarkSweepGC，这两个垃圾收集器都使用并行收集，CMS关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。</p><h3 id="最终JVM参数配置"><a href="#最终JVM参数配置" class="headerlink" title="最终JVM参数配置"></a>最终JVM参数配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xms2G   </span><br><span class="line">-Xmx2G</span><br><span class="line">-XX:MetaspaceSize=256M</span><br><span class="line">-XX:MaxMetaspaceSize=256M</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:MaxTenuringThreshold=15</span><br><span class="line">-XX:NewSize=768m</span><br><span class="line">-XX:MaxNewSize=768m</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC -Xloggc:../logs/gc.log</span><br></pre></td></tr></table></figure><p>上述参数配置后，系统在运行了55分钟后，取出GC日志再次分析，得到分析结果：<br><img src="/images/dld_jvm_optimize/dld_jvm_optimize3.png" alt></p><h3 id="修改后GC详情"><a href="#修改后GC详情" class="headerlink" title="修改后GC详情"></a>修改后GC详情</h3><p><strong>一共进行了 81 次GC，<br>累计停顿时间 2.67 秒，<br>最短停顿时间 0.01256 秒/最长停顿时间 0.12997 秒，<br>平均停顿时间 0.03298 秒，<br>其中0次FULL GC，全是MINOR GC</strong></p><p>查看日志：</p><p><strong>3264.136: [GC (Allocation Failure) 3264.136: [ParNew: 683860K-&gt;52269K(707840K), 0.0343536 secs] 1147153K-&gt;530284K(2018560K), 0.0345308 secs] [Times: user=0.31 sys=0.00, real=0.04 secs]</strong></p><p><strong>3331.824: [GC (Allocation Failure) 3331.824: [ParNew: 681517K-&gt;40268K(707840K), 0.0257484 secs] 1159532K-&gt;518283K(2018560K), 0.0259169 secs] [Times: user=0.29 sys=0.00, real=0.03 secs]</strong></p><p><strong>3339.513: [GC (Allocation Failure) 3339.513: [ParNew: 669516K-&gt;41968K(707840K), 0.0248916 secs] 1147531K-&gt;519983K(2018560K), 0.0250382 secs] [Times: user=0.29 sys=0.00, real=0.02 secs]</strong></p><p>可知，所有的GC都发生在新生代eden区满了的情况下，绝大部分数据在新生代就被回收，这才是正常的GC情况。</p><p>至此，系统恢复正常。由于会不定时发布新功能，因此后期会定期拉取GC日志分析，根据实际情况再进行优化。</p><h2 id="修改前后GC图"><a href="#修改前后GC图" class="headerlink" title="修改前后GC图"></a>修改前后GC图</h2><h3 id="修改前"><a href="#修改前" class="headerlink" title="修改前"></a>修改前</h3><p><img src="/images/dld_jvm_optimize/dld_jvm_optimize4.png" alt></p><h3 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h3><p><img src="/images/dld_jvm_optimize/dld_jvm_optimize5.png" alt></p><p><img src="/images/dld_jvm_optimize/dld_jvm_optimize6.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天公司实施人员反映，某个生产环境的系统运行二三十分钟后会卡死，无法进行任何操作，重启项目后恢复正常。该tomcat未配置任何JVM参数，初步推测可能是内存泄露。在此记录一下分析过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://heart4lion.github.io/categories/JAVA/"/>
    
      <category term="后端" scheme="https://heart4lion.github.io/categories/JAVA/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JVM" scheme="https://heart4lion.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
